/*
 * Produced by:
 *
 * 				Derivative Inc
 *				401 Richmond Street West, Unit 386
 *				Toronto, Ontario
 *				Canada   M5V 3A8
 *				416-591-3555
 *
 * NAME:				CHOP_CPlusPlusBase.h 
 *
 *
 *	Do not edit this file directly!
 *	Make a subclass of CHOP_CPlusPlusBase instead, and add your own 
 *	data/functions.

 *	Derivative Developers:: Make sure the virtual function order
 *	stays the same, otherwise changes won't be backwards compatible
 */


#ifndef __CHOP_CPlusPlusBase__
#define __CHOP_CPlusPlusBase__

#include <windows.h>
#include <cstdio>

#define DLLEXPORT __declspec (dllexport)

#define CHOP_CPLUSPLUS_API_VERSION	1

class CHOP_CPlusPlusBase;
class CHOP_NodeInfo;


// These are the definitions for the C-functions that are used to
// load the library and create instances of the object you define
typedef int (__cdecl *GETCHOPAPIVERSION)(void);
typedef CHOP_CPlusPlusBase* (__cdecl *CREATECHOPINSTANCE)(const CHOP_NodeInfo*);
typedef void (__cdecl *DESTROYCHOPINSTANCE)(CHOP_CPlusPlusBase*);

// These classes are used to pass data to/from the functions you will define

class CHOP_NodeInfo
{
public:
	// The full path to the node

	const char*		nodeFullPath;

	// A unique ID representing the node, no two nodes will ever
	// have the same ID in a single Touch instance.

	unsigned int	uniqueNodeId;

	// This is the handle to the main TouchDesigner window.
	// It's possible this will be 0 the first few times the node cooks,
	// incase it cooks while Touch is still loading up

	HWND			mainWindowHandle;

private:
	int				reserved[19];
};


class CHOP_GeneralInfo
{
public:
	// Set this to true if you want the CHOP to cook every frame, even
	// if none of it's inputs/parameters are changing
	// DEFAULT: false

	bool			cookEveryFrame;

	// Set this to true if you want the CHOP to cook every frame, but only
	// if someone asks for it to cook. So if nobody is using the output from
	// the CHOP, it won't cook. This is difereent from 'cookEveryFrame'
	// since that will cause it to cook every frame no matter what.

	bool			cookEveryFrameIfAsked;

	// Set this to true if you will be outputting a timeslice
	// Outputting a timeslice means the length of the CHOP will be determined
	// by the number of frames that have elapsed since the last time Touch
	// cooked (it will be more than one in cases where it's running slower
	// than the target cook rate), the playbar framerate and the sample
	// rate of the CHOP.
	// For example if you are outputting the CHOP 120hz sample rate, 
	// Touch is running at 60 hz cookrate, and you missed a frame last cook
	// then on this cook the length of the output of this CHOP will be
	// 4 samples. ((120 / 60) * number of playbar frames to output)
	// If this isn't set then you specify the length of the CHOP using
	// the getOutputInfo() function
	// DEFAULT: false

	bool			timeslice;

	// If you are returning 'false' from getOutputInfo, this index will 
	// specify the CHOP input whos attribues you will match 
	// (channel names, length, sample rate etc.)
	// DEFAULT : 0

	int				inputMatchIndex;


private:
	int				reserved[20];
};

class CHOP_FloatInput
{
public:
	const char*		name;
	int				inputNumber;

	// Will contain the 4 floats in the parameter.

	float			values[4];

private:
	int				reserved[20];
};

class CHOP_StringInput
{
public:
	const char*		name;
	int				inputNumber;
	const char*		value;

private:
	int				reserved[20];
};

class CHOP_CHOPInput
{
public:
	const char*		nodeFullPath;
	int				inputNumber;
	int				numChannels;
	int				length;
	float			sampleRate;
	unsigned int	startIndex;

	// This is an array of const char* which tells you the names of the
	// channels. The length of the array is 'numChannels' long.
	// For example names[1] is the name of the 2nd channel
	const char**	names;

	// This is an array of float arrays. The array is 'numChannels' long
	// while each individual array within the array is 'length' long
	// e.g: channels[1][10] will refer to the 11th sample in the 2nd channel 
	const float**	channels;


private:
	int				reserved[20];
};


class CHOP_DATInput
{
public:
	const char*     nodeFullPath;
	int             inputNumber;
	int             numRows;
	int             numCols;
	bool            isTable;

	// data, referenced by [row][col], which will be a const char* for the
	// contents of the cell
	// E.g data[1][1] will be the contents of the cell located at (1, 1)
	const char***   data;

private:
	int             reserved[20];
};


class CHOP_InputArrays
{
public:

	int						numFloatInputs;

	// floatInputs is an array of CHOP_FloatInputs objects, 'numFloatInputs' long
	// e.g floatInputs[0].name

	const CHOP_FloatInput*	floatInputs;


	// The rest of these are similar to the floatInputs description

	int						numCHOPInputs;
	const CHOP_CHOPInput*	CHOPInputs;

	int						numStringInputs;
	const CHOP_StringInput*	stringInputs;

	int						numDATInputs;
	const CHOP_DATInput*	DATInputs;



private:
#ifdef _WIN64
	int				reserved[95];
#else
	int				reserved[98];
#endif
};

class CHOP_OutputInfo
{
public:

	// The number of channels you want to output

	int				numChannels;


	// If you arn't outputting a timeslice, specify the length of the channels
	// here

	int				length;


	// if you arn't outputting a timeslice, specify the start index
	// of the channels here. This is the 'Start' you see when you
	// middle click on a CHOP

	unsigned int	startIndex;


	// Specify the sample rate of the channel data
	// DEFAULT : whatever the timeline FPS is ($FPS)

	float			sampleRate;


	// This is provided for you incase you want to use data from the
	// your inputs/parameters to decide what you will be outputting from
	// the CHOP, you shouldn't change anything in this structure

	const CHOP_InputArrays *inputArrays;

private:

	int				reserved[20];

};




class CHOP_InfoCHOPChan
{
public:
	char*			name;
	float			value;
private:
	int				reserved[10];
};

class CHOP_InfoDATSize
{
public:
	
	// Set this to the size you want the table to be

	int				rows;
	int				cols;

	// Set this to true if you want to return DAT entries on a column
	// by column basis.
	// Otherwise set to false, and you'll be expected to set them on
	// a row by row basis.

	bool			byColumn;


private:
	int				reserved[10];
};

class CHOP_InfoDATEntries
{
public:

	// This is an array of char* pointers which you are expected to assign
	// The start off as NULL, you need to allocate or assign constant/statis
	// strings to them
	// e.g values[1] = "myColumnName";

	char**			values;

private:
	int				reserved[10];
};


class CHOP_Output
{
public:
	CHOP_Output(int nc, int l, float s, unsigned int st):	
											numChannels(nc),
											length(l),
											sampleRate(s),
											startIndex(st)
	{
	}

	// Info about what you are expected to output
	const int		numChannels;
	const int		length;
	const float		sampleRate;
	const unsigned int startIndex;

	// This is an array of const char* that tells you the channel names
	// of the channels you are providing values for. It's 'numChannels' long. 
	// E.g names[3] is the name of the 4th channel
	const char**	names;

	// This is an array of float arrays, the length of the array is
	// 'numChannels', while the length of each of the arrays each entry
	// points to is 'length'.
	// For example channels[1][10] will point to the 11th sample in the 2nd
	// channel
	float**			channels;


private:

	int				reserved[20];
};

/***** FUNCTION CALL ORDER DURING A COOK ******/
/*

	When the CHOP cooks the functions will be called in this order

	getGeneralInfo()
	getOutputInfo()
	if getOutputInfo() returns true
	{
		getChannelName() once for each channel needed 
	}
	execute()
	getNumInfoCHOPChans()
	for the number of chans returned getNumInfoCHOPChans()
	{
		getInfoCHOPChan()
	}
	getInfoDATSize()
	for the number of rows/cols returned by getInfoDATSize()
	{
		getInfoDATEntries()
	}
	getInfoPopupString()
	getWarningString()
	getErrorString()
*/

/*** DO NOT EDIT THIS CLASS, MAKE A SUBCLASS OF IT INSTEAD ***/
class CHOP_CPlusPlusBase
{
protected:
	CHOP_CPlusPlusBase()
	{
	}


public:

	virtual ~CHOP_CPlusPlusBase()
	{
	}

	// BEGIN PUBLIC INTERFACE

	// Some general settings can be assigned here (if you ovierride it)

	virtual void		getGeneralInfo(CHOP_GeneralInfo*)
						{
						}


	// This function is called so the class can tell the CHOP how many
	// channels it wants to output, their length etc.
	// Return true if you specify the output here
	// Return false if you want the output to be set by matching
	// the channel names, length, sample rate etc. of one of your inputs
	// The input that is used is chosen by setting the 'inputMatchIndex'
	// memeber in getGeneralInfo()
	// The CHOP_OutputFormat class is pre-filled with what the CHOP would
	// output if you return false, so you can just tweak a few settings
	// and return true if you want

	virtual bool		getOutputInfo(CHOP_OutputInfo*)
						{
							return false;
						}


	// This function will be called after getOutputInfo() asking for
	// the channel names. It will get called once for each channel name
	// you need to specify. If you returned 'false' from getOutputInfo()
	// it won't be called.

	virtual const char*	getChannelName(int index, void* reserved)
						{
							return "chan1";
						}


	// In this function you do whatever you want to fill the framebuffer
	// 
	// See the CHOP_InputArrays class definition for more details on it's
	// contents

	virtual void		execute(const CHOP_Output*,
								const CHOP_InputArrays*,
								void* reserved) = 0;


	// Override these methods if you want to output values to the Info CHOP/DAT
	// returning 0 means you dont plan to output any Info CHOP channels

	virtual int			getNumInfoCHOPChans()
						{
							return 0;
						}

	// Specify the name and value for CHOP 'index',
	// by assigning something to 'name' and 'value' members of the
	// CHOP_InfoCHOPChan class pointer that is passed (it points
	// to a valid instance of the class already.
	// the 'name' pointer will initially point to NULL
	// you must allocate memory or assign a constant string
	// to it.

	virtual void		getInfoCHOPChan(int index,
										CHOP_InfoCHOPChan *chan)
						{
						}


	// Return false if you arn't returning data for an Info DAT
	// Return true if you are.
	// Set the members of the CHOP_InfoDATSize class to specify
	// the dimensions of the Info DAT

	virtual bool		getInfoDATSize(CHOP_InfoDATSize *infoSize)
						{
							return false;
						}

	// You are asked to assign values to the Info DAT 1 row or column at a time
	// The 'byColumn' variable in 'getInfoDATSize' is how you specify
	// if it is by column or by row.
	// 'index' is the row/column index
	// 'nEntries' is the number of entries in the row/column

	virtual void		getInfoDATEntries(int index,
											int nEntries,
											CHOP_InfoDATEntries *entries)
						{
						}

	// You can use this function to put the node into a warning state
	// with the returned string as the message.
	// Return NULL if you don't want it to be in a warning state.
	virtual const char* getWarningString() 
						{
							return NULL; 
						}

	// You can use this function to put the node into a error state
	// with the returned string as the message.
	// Return NULL if you don't want it to be in a error state.
	virtual const char* getErrorString() 
						{
							return NULL; 
						}

	// Use this function to return some text that will show up in the
	// info popup (when you middle click on a node)
	// Return NULL if you don't want to return anything.
	virtual const char*	getInfoPopupString() 
						{
							return NULL;
						}

	// END PUBLIC INTERFACE
				

private:

	// Reserved for future features
	virtual int		reservedFunc4() { return 0; }
	virtual int		reservedFunc5() { return 0; }
	virtual int		reservedFunc6() { return 0; }
	virtual int		reservedFunc7() { return 0; }
	virtual int		reservedFunc8() { return 0; }
	virtual int		reservedFunc9() { return 0; }
	virtual int		reservedFunc10() { return 0; }
	virtual int		reservedFunc11() { return 0; }
	virtual int		reservedFunc12() { return 0; }
	virtual int		reservedFunc13() { return 0; }
	virtual int		reservedFunc14() { return 0; }
	virtual int		reservedFunc15() { return 0; }
	virtual int		reservedFunc16() { return 0; }
	virtual int		reservedFunc17() { return 0; }
	virtual int		reservedFunc18() { return 0; }
	virtual int		reservedFunc19() { return 0; }
	virtual int		reservedFunc20() { return 0; }

	int				reserved[400];

};

#endif

